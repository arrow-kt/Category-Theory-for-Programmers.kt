```Haskell
template<class A, class B>
std::function<optional<B>(optional<A>)>
fmap(std::function<B(A)> f) {
    return [f](optional<A> opt) {
        if (!opt.isValid())
            return optional<B>{};
        else
            return optional<B>{ f(opt.val()) };
    };
}
```
```kotlin:ank:playround
import arrow.core.None
import arrow.core.Option
import arrow.core.Some
import arrow.core.extensions.option.foldable.fold

fun <A, B> fmap(f: (A) -> B) =
    { opt: Option<A> ->
        opt.fold(
            ifEmpty = { None },
            ifSome = { a -> Some(f(a)) }
        )
    }
```
................
```cpp
template<class A, class B>
optional<B> fmap(std::function<B(A)> f, optional<A> opt) {
    if (!opt.isValid())
        return optional<B>{};
    else
        return optional<B>{ f(opt.val()) };
}
```
```kotlin:ank:playground
import arrow.core.Option
import arrow.core.None
import arrow.core.Some
import arrow.core.extensions.option.foldable.fold

fun <A, B> fmap(f: (A) -> B, opt: Option<A>): Option<B> =
    opt.fold(ifEmpty = { None },
        ifSome = { a -> Some(f(a)) })
        
```
................
```Haskell
auto g = fmap(f);
```
```kotlin
auto(g) == fmap(f)
```
................
```Haskell
class Eq a where
    (==) :: a -> a -> Bool
```
```kotlin:ank:silent
interface Eq<F> {
  fun F.eqv(b: F): Boolean

  fun F.neqv(b: F): Boolean =
    !eqv(b)
}
```
................
```Haskell
data Point = Pt Float Float
```
```kotlin:ank:silent
data class Pt(val x: Float, val y: Float) {
    companion object
}
```
................
```Haskell
instance Eq Point where
(Pt x y) == (Pt x' y') = x == x' && y == y'
```
```kotlin:ank:silent
import arrow.extension

@extension
interface PtEq : Eq<Pt> {
    override fun Pt.eqv(b: Pt): Boolean = x == b.x && y == b.y
}
```
................
```Haskell
class Functor f where
    fmap :: (a -> b) -> f a -> f b
```
```kotlin:ank:playground
import arrow.Kind
	
interface Functor<F> {
    fun <A, B> Kind<F, A>.map(f: (A) -> B): Kind<F, B>
}
```
................
```Haskell
instance Functor Maybe where
    fmap _ Nothing = Nothing
    fmap f (Just x) = Just (f x)
```
```kotlin
sealed class Option<out A> {
    //â€¦
    inline fun <B> map(f: (A) -> B): Option<B> =
        flatMap { a -> Some(f(a)) }

    inline fun <B> flatMap(f: (A) -> Option<B>): Option<B> =
        when (this) {
              is None -> this
              is Some -> f(t).fix()
            }
}
```
................
```Haskell
data List a = Nil | Cons a (List a)
```
```kotlin:ank:playground
sealed class List<out A> {
    object Nil : List<Nothing>()
    data class Cons<out A>(val head: A, val tail: List<A>) : List<A>()
}
```
................
```Haskell
fmap :: (a -> b) -> (List a -> List b)
```ddd
```kotlin
fun <A, B> fmap(): ((A) -> B) -> ((Kind<ForListK, A>) -> Kind<ForListK, B>)
```
................
```Haskell
fmap f (Cons x t) = Cons (f x) (fmap f t)
```
```kotlin:ank:playground
import arrow.data.ForListK
import arrow.data.extensions.listk.functor.functor
import arrow.data.ListK
import arrow.Kind

fun <A, B> fmap(): ((A) -> B, Kind<ForListK, A>) -> Kind<ForListK, B> =
    { f, list -> ListK.functor().lift(f)(list) }
```
................
```Haskell
instance Functor List where
    fmap _ Nil = Nil
    fmap f (Cons x t) = Cons (f x) (fmap f t)
```
```kotlin:ank:playground
import arrow.data.ForListK
import arrow.data.ListK
import arrow.Kind
import arrow.data.fix
import arrow.typeclasses.Functor
import arrow.extension

@extension
interface ListKFunctor : Functor<ForListK> {
    override fun <A, B> Kind<ForListK, A>.map(f: (A) -> B): ListK<B> =
        fix().map(f)
}
```
................
```cpp
std::vector<int> v{ 1, 2, 3, 4 };
auto w = fmap([](int i) { return i * i; }, v);
std::copy( std::begin(w)
         , std::end(w)
         , std::ostream_iterator(std::cout, ", "));
```
```kotlin:ank:playground
main(){
  //sampleStart
  val v = listOf(1, 2, 3, 4)
  val output = v.map { it * it }
  //sampleEnd
  println(output)
}
```
................
```Haskell
fmap :: (a -> b) -> (r -> a) -> (r -> b)
```
```kotlin
fun <A, B, R> fmap(f: (A) -> B, g: (R) -> A): ((R) -> B)
```
................
```Haskell
instance Functor ((->) r) where
  fmap f g = f . g
```
```kotlin:ank:playground
fun <A, B, R> fmap(f: (A) -> B, g: (R) -> A): ((R) -> B) =
  { f(g(it)) }
```
................
```Haskell
fmap f g = (.) f g
```
```kotlin:ank:playground
import arrow.core.andThen

fun <A, B, R> fmap(f: (A) -> B, g: (R) -> A): ((R) -> B) =
  g andThen f
```
................
```Haskell
fmap = (.)
```
```kotlin
fmap == andThen
```
................
```Haskell
nats :: [Integer]
nats = [1..]
```
```kotlin:ank:silent
val nats = generateSequence(1) { it + 1 }
```
................
```Haskell
data Const c a = Const c
```
```kotlin:ank:playground
data class Const<A, out T>(private val value: A) 
```
................
```Haskell
fmap :: (a -> b) -> Const c a -> Const c b
```
```kotlin
fun <A, R, T> Const<A, T>.fmap(f: (T) -> R): Const<A, R>
```
................
```Haskell
instance Functor (Const c) where
  fmap _ (Const v) = Const (v)
```
```kotlin:ank:playground
import arrow.typeclasses.Const

fun <A, R, T> Const<A, T>.fmap(f: (T) -> R): Const<A, R> =
  retag<R>()
```
................
```cpp
template<class C, class A>
struct Const {
  Const(C v) : _v(v) {}
  C _v;
}
```
```kotlin:ank:playground
import arrow.typeclasses.Const

@Suppress("UNCHECKED_CAST")
fun <U> retag(): Const<A, U> = this as Const<A, U>
```
................
```cpp
template<class C, class A, class B>
Const<C, B> fmap(std::function<B(A)> f, Const<C, A> c) {
  return Const<C, B>{c._v};
}
```
```kotlin:ank:playground
import arrow.typeclasses.Const

@Suppress("UNCHECKED_CAST")
fun <A, R, T> Const<A, T>.fmap(f: (T) -> R): Const<A, R> =
  this as Const<A, R>
```
................
```Haskell
maybeTail :: [a] -> Maybe [a]
maybeTail [] = Nothing
maybeTail (x:xs) = Just xs
```
```kotlin:ank:playground
import arrow.core.None
import arrow.core.Option
import arrow.core.Some

fun <A> List<A>.maybeTail(): Option<A> =
  when (isEmpty()) {
    true -> None
    false -> Some(first())
  }
```
................
```Haskell
square x = x * x
```
```kotlin:ank:silent
val square = { x: Int -> x * x }
```
................
```Haskell
mis :: Maybe [Int]
mis = Just [1, 2, 3]
```
```kotlin:ank:playground
import arrow.core.Option
import arrow.core.Some

val mis: Option<List<Int>> = Some(listOf(1, 2, 3))
```
................
```Haskell
mis2 = fmap (fmap square) mis
```
```kotlin:ank:playground
import arrow.core.Option
import arrow.core.Some

val mis: Option<List<Int>> = Some(listOf(1, 2, 3))
val square = { x: Int -> x * x }

main() {
  //sampleStart
  val mis2 = mis.map { it.map(square) }
  //sampleEnd
  println(mis2)
}
```
................
```Haskell
mis2 = (fmap . fmap) square mis
```
```kotlin:ank:playground
import arrow.core.Option
import arrow.core.Some

val mis: Option<List<Int>> = Some(listOf(1, 2, 3))
val square = { x: Int -> x * x }

main() {
  //sampleStart
  val composedMap = { o: Option<List<Int>>, f: (Int) -> Int ->
    o.map { it.map(f) }
  }
  
  val mis2 = composedMap(mis, square)
  //sampleEnd
  println(mis2)
}
```
................
```Haskell
fmap :: (a -> b) -> (f a -> f b)
```
```kotlin
fun <A, B> fmap(f: (A) -> B): ((Kind<F, A>) -> Kind<F, B>)
```
................
```Haskell
square :: Int -> Int
```
```kotlin
val square: ((Int) -> Int)
```
................
```Haskell
[Int] -> [Int]
```
```kotlin
((Int) -> Int)
```
................
```Haskell
Maybe [Int] -> Maybe [Int]
```