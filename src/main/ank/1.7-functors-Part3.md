```Haskell
(->) a b
```
```kotlin:ank:silent

```
................
```Haskell
(->) a
```
```kotlin:ank:silent

```
................
```Haskell
fmap :: (a -> b) -> (r -> a) -> (r -> b)
```
```kotlin
fun <A, B, R> fmap(f: (A) -> B, g: (R) -> A): (R) -> B
```
................
```Haskell
instance Functor ((->) r) where
  fmap f g = f . g
```
```kotlin:ank:playground
fun <A, B, R> fmap(f: (A) -> B, g: (R) -> A): (R) -> B =
  { f(g(it)) }
```
................
```Haskell
fmap f g = (.) f g
```
```kotlin:ank:playground
import arrow.core.andThen

fun <A, B, R> fmap(f: (A) -> B, g: (R) -> A): ((R) -> B) =
  g andThen f
```
................
```Haskell
fmap = (.)
```
```kotlin
fmap == andThen
```
................
```Haskell
nats :: [Integer]
nats = [1..]
```
```kotlin:ank:silent
val nats = generateSequence(1) { it + 1 }
```
................
```Haskell
data Const c a = Const c
```
```kotlin:ank:playground
data class Const<A, out T>(private val value: A) 
```
................
```Haskell
fmap :: (a -> b) -> Const c a -> Const c b
```
```kotlin
fun <A, R, T> Const<A, T>.fmap(f: (T) -> R): Const<A, R>
```
................
```Haskell
instance Functor (Const c) where
    fmap _ (Const v) = Const v
```
```kotlin:ank:playground
import arrow.typeclasses.Const

fun <A, R, T> Const<A, T>.fmap(f: (T) -> R): Const<A, R> =
  this as Const<A, R>
```
................
```Haskell
maybeTail :: [a] -> Maybe [a]
maybeTail [] = Nothing
maybeTail (x:xs) = Just xs
```
```kotlin:ank
//TODO: run this with ank successfully and other where `List#map` or other functions are used
import arrow.core.Option
import arrow.core.toOption

fun <A> List<A>.maybeTail(): Option<A> =
  firstOrNull().toOption()
```
................
```Haskell
square x = x * x

mis :: Maybe [Int]
mis = Just [1, 2, 3]

mis2 = fmap (fmap square) mis
```
```kotlin:ank:silent
import arrow.core.Option
import arrow.core.Some

val square = { x: Int -> x * x }

val mis: Option<List<Int>> = Some(listOf(1, 2, 3))

fun main() {
  //sampleStart
  val mis2 = mis.map { it.map(square) }
  //sampleEnd
  println(mis2)
}
```
................
```Haskell
mis2 = (fmap . fmap) square mis
```
```kotlin:ank:playground
import arrow.core.Option
import arrow.core.Some

val mis: Option<List<Int>> = Some(listOf(1, 2, 3))
val square = { x: Int -> x * x }

fun main() {
  //sampleStart
  val composedMap = { o: Option<List<Int>>, f: (Int) -> Int ->
    o.map { it.map(f) }
  }
  
  val mis2 = composedMap(mis, square)
  //sampleEnd
  println(mis2)
}
```
................
```Haskell
fmap :: (a -> b) -> (f a -> f b)
```
```kotlin
fun <A, B> fmap(f: (A) -> B): (Kind<F, A>) -> Kind<F, B>
```
................
```Haskell
square :: Int -> Int
```
```kotlin
val square: (Int) -> Int
```
................
```Haskell
[Int] -> [Int]
```
```kotlin
(List<Int>) -> List<Int>
```
................
```Haskell
Maybe [Int] -> Maybe [Int]
```
```kotlin
(Option<List<Int>>) -> Option<List<Int>>
```
