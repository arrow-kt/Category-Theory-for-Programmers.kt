```Haskell
p' = p . m
q' = q . m
```
```kotlin
val `p'` = p compose m
val `q'` = q compose m
```
................
```Haskell
contramap :: (c' -> c) -> (c -> LimD) -> (c' -> LimD)
contramap f u = u . f
```
```kotlin:ank:silent
import arrow.core.compose
object LimD

fun <A, B> contramap(f: (A) -> B, u: (B) -> LimD): ((A) -> LimD) = u compose f
```
................
```Haskell
f :: a -> b
g :: a -> b
```
```kotlin
val f: (A) -> B
val g: (A) -> B
```
................
```Haskell
p :: c -> a
q :: c -> b
```
```kotlin
val p: (C) -> A
val q: (C) -> B
```
................
```Haskell
q = f . p
q = g . p
```
```kotlin
val q = f compose p
val q = g compose p
```
................
```Haskell
f . p = g . p
```
```kotlin
f compose p == g compose p
```
................
```Haskell
f (x, y) = 2 * y + x
g (x, y) = y - x
```
```kotlin:ank:playground
val f = { x: Int, y: Int -> 2 * y + x }
val g = { x: Int, y: Int -> y - x }
```
................
```Haskell
p t = (t, (-2) * t)
```
```kotlin:ank:playground
import arrow.core.toT

val p = { t: Int -> t toT (-2) * t }
```
................
```Haskell
f . p' = g . p'
```
```kotlin
f compose `p'` == g compose `p'`
```
................
```Haskell
p'() = (0, 0)
```
```kotlin:ank:playground
import arrow.core.toT

fun `p'`() = 0 toT 0
```
................
```Haskell
p' = p . h
```
```kotlin
val `p'` = p compose h
```
................
```Haskell
h () = 0
```
```kotlin:ank:plaground
fun h() = 0
```
................
```Haskell
f :: a -> b
g :: c -> b
```
```kotlin
val f: (A) -> B
val g: (C) -> B
```
................
```Haskell
p :: d -> a
q :: d -> c
r :: d -> b
```
```kotlin
val p: (D) -> A
val q: (D) -> C
val r: (D) -> B
```
................
```Haskell
g . q = f . p
```
```kotlin
g compose q == f compose p
```
................
```Haskell
f x = 1.23
```
```kotlin
val f: (A) -> Double = { _: A -> 1.23 }
```
................
```Haskell
newtype ToString a = ToString (a -> String)
instance Contravariant ToString where 
    contramap f (ToString g) = ToString (g . f)
```
```kotlin:ank:playground
import arrow.Kind
import arrow.extension
import arrow.typeclasses.Contravariant

@extension
interface ToStringContravariant : Contravariant<ForToString> {
  override fun <A, B> Kind<ForToString, A>.contramap(f: (B) -> A): Kind<ForToString, B> =
    ToString { this.fix().f(f(it)) }
}
```
................
```Haskell
ToString (Either b c) ~ (b -> String, c -> String)
```
```kotlin
typealias ToStringEither<A, B> = ToString<Either<A, B>>
typealias TupleToString<A, B> = Tuple2<(A) -> String, (B) -> String>

ToStringEither == TupleToString
```
................
```Haskell
r -> (a, b) ~ (r -> a, r -> b)
```
```kotlin
(R) -> (A, B) ==  Tuple2<(R) -> A, (R) -> B>
```
